<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Depression Screening (demo)</title>
  <style>
    body{font-family:system-ui,Segoe UI,Arial,sans-serif;margin:20px}
    .q{font-size:18px;margin:10px 0}
    button{padding:10px 16px;border-radius:10px;border:1px solid #ddd;cursor:pointer}
    #log{white-space:pre-wrap;background:#fafafa;border:1px solid #eee;padding:10px;border-radius:8px;margin-top:12px;height:160px;overflow:auto}
    video{width:480px;border-radius:12px;border:1px solid #eee}
  </style>
</head>
<body>
  <h2>üé•üé§ Depression Screening (demo)</h2>
  <p>We‚Äôll ask <b><span id="nq"></span></b> short questions. When you hit <b>Record</b>, we capture <b><span id="secs"></span>s</b> of webcam + mic, upload, extract features, and move on.</p>

  <div class="q"><b>Question <span id="qnum">1</span>:</b> <span id="qtext"></span></div>

  <video id="preview" autoplay muted playsinline></video><br/><br/>
  <button id="btn">Record <span id="btnsecs"></span>s</button>
  <button id="skip">Skip</button>

  <div id="log"></div>

  <script>
    // Same constants your Flask template used
    const QUESTIONS = [
      "hi i'm ellie thanks for coming in today",
      "i was created to talk to people in a safe and secure environment",
      "think of me as a friend i don't judge i can't i'm a computer",
      "i'm here to learn about people and would love to learn about you",
      "i'll ask a few questions to get us started and please feel free to tell me anything",
      "how are you doing today",
      "that's good",
      "where are you from originally"
    ];
    const SEC = 5;

    document.getElementById('nq').textContent = QUESTIONS.length;
    document.getElementById('secs').textContent = SEC;
    document.getElementById('btnsecs').textContent = SEC;

    const SID = (crypto?.randomUUID?.() || Math.random().toString(36).slice(2));
    let idx = 0, mediaStream=null, busy=false;

    const qnum = document.getElementById('qnum');
    const qtext = document.getElementById('qtext');
    const btn = document.getElementById('btn');
    const skip = document.getElementById('skip');
    const log = document.getElementById('log');
    const preview = document.getElementById('preview');

    function setQ() {
      qnum.textContent = (idx+1);
      qtext.textContent = QUESTIONS[idx];
    }
    setQ();

    async function getStream(){
      if (!mediaStream) {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video:{ width:{ideal:320}, height:{ideal:240} },
          audio:true
        });
        preview.srcObject = mediaStream;
      }
      return mediaStream;
    }

    function append(msg){ log.textContent += msg + "\n"; log.scrollTop = log.scrollHeight; }

    async function recordOnce(){
      if (busy) return;
      busy = true; btn.disabled = true; skip.disabled = true;

      try {
        const stream = await getStream();
        const rec = new MediaRecorder(stream, {mimeType: 'video/webm;codecs=vp8,opus'});
        let chunks = [];
        rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
        rec.start();
        append("üéôÔ∏è Recording...");
        await new Promise(r => setTimeout(r, SEC*1000));
        rec.stop();
        await new Promise(r => rec.onstop = r);
        const blob = new Blob(chunks, {type: 'video/webm'});
        append("‚¨ÜÔ∏è Uploading " + Math.round(blob.size/1024) + " KB");
        const fd = new FormData();
        fd.append('sid', SID);
        fd.append('qidx', idx);
        fd.append('file', blob, 'seg.webm');

        // Abort if server stalls
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), 30000);

        let ok = false;
        try {
          // üëá goes to Vercel, which proxies to Render via vercel.json
          const res = await fetch('/api/segment', {method:'POST', body:fd, signal: ctrl.signal});
          clearTimeout(t);
          const j = await res.json().catch(() => ({}));
          ok = res.ok && j && j.ok;
          if (ok) append("‚úÖ Segment saved (" + j.count + "/" + QUESTIONS.length + ")");
          else append("‚ùå Segment failed ‚Äî skipping this question.");
        } catch (err) {
          clearTimeout(t);
          append("‚ùå Upload/record error: " + err);
        }

        idx++;
        if (idx < QUESTIONS.length) { setQ(); }
        else { finalize(); }
      } finally {
        busy = false; btn.disabled = false; skip.disabled = false;
      }
    }

    async function finalize(){
      append("üß† Finalizing prediction...");
      const res = await fetch('/api/finalize?sid=' + SID);
      const j = await res.json().catch(()=>({}));
      if (!res.ok || !j) { append("‚ùå Finalize failed."); return; }
      append("üéØ P(Depressed)=" + j.p_depressed.toFixed(3) + " ‚Üí " + j.label);
    }

    btn.onclick = recordOnce;
    skip.onclick = () => { if (!busy) { idx++; if (idx<QUESTIONS.length) setQ(); else finalize(); } };
  </script>
</body>
</html>
